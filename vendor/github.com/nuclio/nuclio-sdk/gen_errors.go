// +build ignore
// Generate errors.go from constants in net/http

package main

import (
	"flag"
	"go/importer"
	"log"
	"os"
	"sort"
	"strings"
	"text/template"
)

const (
	statusPrefix = "Status"

	codeTemplateText = `// Automatically generated by gen_errors.go

package nuclio

import (
	"errors"
	"net/http"
)

// WithStatusCode is an error with status code
type WithStatusCode interface {
	StatusCode() int
}

// ErrorWithStatusCode implements both error and WithStatusCode
type ErrorWithStatusCode struct {
	error
	statusCode int
}

// StatusCode returns the status code
func (ewsc *ErrorWithStatusCode) StatusCode() int {
	return ewsc.statusCode
}

{{range .}}
// {{. | StatusToError}} is a {{.}} Error
var {{. | StatusToError}} = ErrorWithStatusCode{statusCode: http.{{.}}}

// New{{. | StatusToError}} returns a new {{. | StatusToError}} with custom error message
func New{{. | StatusToError}}(message string) error {
	return &ErrorWithStatusCode{
		error: errors.New(message),
		statusCode: http.{{.}},
	}
}
{{end}}
`
)

// StatusToError convert http status name to error name
// (e.g. "StatusAccepted" -> "ErrAccepted")
func StatusToError(status string) string {
	return "Err" + status[len(statusPrefix):]
}

func main() {
	flag.Parse() // Support -h, --help

	pkg, err := importer.Default().Import("net/http")
	if err != nil {
		log.Fatal(err)
	}

	var names []string
	for _, name := range pkg.Scope().Names() {
		if !strings.HasPrefix(name, statusPrefix) || name == "StatusOK" {
			continue
		}

		obj := pkg.Scope().Lookup(name)
		if obj.Type().String() != "untyped int" {
			continue
		}

		names = append(names, name)
	}
	sort.Strings(names)

	funcMap := template.FuncMap{"StatusToError": StatusToError}
	codeTemplate, err := template.New("").Funcs(funcMap).Parse(codeTemplateText)
	if err != nil {
		log.Fatal(err)
	}

	out, err := os.Create("errors.go")
	if err != nil {
		log.Fatal(err)
	}

	if err := codeTemplate.Execute(out, names); err != nil {
		log.Fatal(err)
	}
}
