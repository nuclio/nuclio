
<!DOCTYPE html>

<html lang="go">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>v3ioStream: Iguazio Data Science Platform Stream Trigger &#8212; nuclio 1.12.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="v3iostream-iguazio-data-science-platform-stream-trigger">
<h1>v3ioStream: Iguazio Data Science Platform Stream Trigger<a class="headerlink" href="#v3iostream-iguazio-data-science-platform-stream-trigger" title="Permalink to this heading">¶</a></h1>
<p><strong>In This Document</strong></p>
<ul class="simple">
<li><p><span class="xref myst">Overview</span></p></li>
<li><p><span class="xref myst">Consuming messages through a consumer group</span></p>
<ul>
<li><p><span class="xref myst">Consumption example</span></p></li>
<li><p><span class="xref myst">Explicit offset commits</span></p></li>
</ul>
</li>
<li><p><span class="xref myst">Dashboard configuration</span></p></li>
<li><p><span class="xref myst">Example</span></p></li>
</ul>
<p><a id="overview"></a></p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>The Nuclio <code class="docutils literal notranslate"><span class="pre">v3ioStream</span></code> trigger allows users to process messages that are sent to an Iguazio Data Science Platform (<strong>&quot;platform&quot;</strong>) data stream (a.k.a. <strong>&quot;v3io stream&quot;</strong>). To simplify, you send messages to a platform stream, instruct Nuclio to read from this stream, and then your function handler is called once for every stream message.</p>
<p>In the real world, however, you might want to divide the message-processing load across the replicas by using multiple function replicas to read from the same stream. These function replicas must work together to split the stream messages among themselves as fairly as possible, without losing any messages and without processing the same message more than once (to the best of their ability).</p>
<p>To this end, Nuclio leverages consumer groups that are built into the platform's Go library (<code class="docutils literal notranslate"><span class="pre">v3io-go</span></code>). When one or more Nuclio replicas join a consumer group, each replica receives its equal share of the shards, based on the number of replicas that are defined in the function (see details later in this document).</p>
<p>When a Nuclio replica is assigned a set of shards, the replica can start using Nuclio workers to read from the shards and handle the records consumption. It's currently guaranteed that a given shard is handled only by one replica, and that the messages are processed sequentially; that is, a message is read and handled only after the handling of the previous message in the shard is completed.</p>
<p><a id="consume-messages"></a></p>
</section>
<section id="consuming-messages-through-a-consumer-group">
<h2>Consuming messages through a consumer group<a class="headerlink" href="#consuming-messages-through-a-consumer-group" title="Permalink to this heading">¶</a></h2>
<p>When a function replica with a <code class="docutils literal notranslate"><span class="pre">v3ioStream</span></code> trigger starts up, it reads a stream state object that's stored alongside the stream shards. This object has an attribute for each consumer group that contains the following information:</p>
<ul class="simple">
<li><p>The <strong>members</strong> (in this case, Nuclio function replicas) that are currently active in the consumer group.</p></li>
<li><p>The last time that each member refreshed its keep-alive field (<code class="docutils literal notranslate"><span class="pre">last_heartbeat</span></code>).</p></li>
<li><p>The shards that are being handled by each member.</p></li>
</ul>
<p>The replica checks for stale members - replicas who haven't refreshed their <code class="docutils literal notranslate"><span class="pre">last_heartbeat</span></code> field within the allotted time frame, as set in the session timeout - and removes their entries from the state object's consumer-group attribute. Then, the replica checks for shards that aren't handled by any member, and registers itself with the consumer group as the owner of a fair portion of these shards by adding an entry to the consumer-group attribute.</p>
<blockquote>
<div><p><strong>Note:</strong> It's possible that multiple replicas might simultaneously want to modify the same consumer-group attribute in the stream's state object. To protect against this, each replica performs read-modify-write with <code class="docutils literal notranslate"><span class="pre">mtime</span></code> protection (which is enforced by the <code class="docutils literal notranslate"><span class="pre">v3io-go</span></code> library); meaning, the consumer-group attribute is written only if the last-modification time (<code class="docutils literal notranslate"><span class="pre">mtime</span></code>) value hasn't changed since the read. If this condition isn't met and the attribute isn't written, the replica retries the read-modify-write process with a random exponential backoff until the write succeeds.</p>
</div></blockquote>
<p>Upon receiving its shard assignment, the replica spawns a Go routine (&quot;thread&quot;) for each shard. Each Go routine identifies the current shard offset within the replica's consumer group (which is stored as an attribute in the shard), and starts pulling messages from this offset. When there's no offset information (for example, for the first read from a consumer-group shard), the replica performs a seek for the earliest or latest shard record, according to the function's seek configuration. The function handler is called for each read message.</p>
<p>For each read message, Nuclio &quot;marks&quot; the sequence number as handled. Periodically, the latest marked sequence number for each shard is &quot;committed&quot; (written to the shard's offset attribute). This allows future replicas to pick up where the previous replica left off without affecting performance.</p>
<p><a id="consumption-example"></a></p>
<section id="consumption-example">
<h3>Consumption example<a class="headerlink" href="#consumption-example" title="Permalink to this heading">¶</a></h3>
<p>To illustrate the consumption mechanism, assume a deployed Nuclio function with minimum and maximum replicas configurations of<code class="docutils literal notranslate"><span class="pre">3</span></code>; the function is configured to read from a <code class="docutils literal notranslate"><span class="pre">/my-stream</span></code> stream with 12 shards using the consumer group <code class="docutils literal notranslate"><span class="pre">cg0</span></code>.</p>
<p>The first replica comes up and reads the stream-state object, but finds that it doesn't contain information about the consumer group. It therefore adds a new consumer-group attribute to the state object, registers itself as a member of the consumer group (by adding a relevant entry to the consumer-group attribute), and monopolizes a third of the shards (<code class="docutils literal notranslate"><span class="pre">12</span> <span class="pre">/</span> <span class="pre">3</span> <span class="pre">=</span> <span class="pre">4</span></code>).</p>
<p>The first replica spawns four Go routines to read from the four shards. Each Go routine reads the offset attribute that's stored in the shard, only to find that it doesn't exist - because this is the first time that the shard is read through consumer group <code class="docutils literal notranslate"><span class="pre">cg0</span></code>. It therefore seeks the earliest or latest shard record (depending on the function configuration) and starts reading batches of messages, sending each message to the function handler as an event. The replica then periodically does the following:</p>
<ul class="simple">
<li><p>Commits the offsets back to the shards' offset attribute.</p></li>
<li><p>Updates the <code class="docutils literal notranslate"><span class="pre">last_heartbeat</span></code> field to <code class="docutils literal notranslate"><span class="pre">now()</span></code> to indicate that it's alive.</p></li>
<li><p>Identifies and removes stale members.</p></li>
</ul>
<p>The second and third replicas come up and register themselves in a similar manner and perform similar steps.</p>
<p>The following demonstrates the replica configurations for this example:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;member_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;replica1&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;shards&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0-3&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;last_heartbeat&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t0&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;member_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;replica2&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;shards&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;4-7&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;last_heartbeat&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t1&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;member_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;replica3&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;shards&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;8-11&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;last_heartbeat&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;t2&quot;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
<p><a id="example-function-redeployment"></a></p>
<section id="function-redeployment">
<h4>Function redeployment<a class="headerlink" href="#function-redeployment" title="Permalink to this heading">¶</a></h4>
<p>At some point, the user decides to redeploy the function. Because by default, Nuclio uses the rolling-update deployment strategy, Kubernetes terminates the replicas one by one. The <code class="docutils literal notranslate"><span class="pre">replica1</span></code> pod stops, and a new <code class="docutils literal notranslate"><span class="pre">replica1</span></code> pod is brought up and follows the same startup procedure: it reads the state object's consumer-group attribute and looks for free shards to take over; initially, it won't find any, because the <code class="docutils literal notranslate"><span class="pre">last_heartbeat</span></code> field of <code class="docutils literal notranslate"><span class="pre">replica1</span></code> is still within the session timeout period and <code class="docutils literal notranslate"><span class="pre">replica2</span></code> and <code class="docutils literal notranslate"><span class="pre">replica3</span></code> keep updating their <code class="docutils literal notranslate"><span class="pre">last_heartbeat</span></code> field.</p>
<p>At this stage, <code class="docutils literal notranslate"><span class="pre">replica1</span></code> backs off and retries periodically until it eventually detects that the elapsed time since <code class="docutils literal notranslate"><span class="pre">replica1</span></code>'s <code class="docutils literal notranslate"><span class="pre">last_heartbeat</span></code> value exceeds the session's timeout period. <code class="docutils literal notranslate"><span class="pre">replica1</span></code> then removes the previous <code class="docutils literal notranslate"><span class="pre">replica1</span></code> instance from the consumer group (by removing its entry from the group's attribute in the stream's state object). It then detects that there are free shards and adds a <code class="docutils literal notranslate"><span class="pre">replica1</span></code> entry to the state object's consumer-group attribute to register itself as a member and take over a fair portion of the free shards.</p>
<blockquote>
<div><p><strong>Note:</strong> It's also possible for <code class="docutils literal notranslate"><span class="pre">replica1</span></code> to be removed from the consumer group by <code class="docutils literal notranslate"><span class="pre">replica2</span></code> or <code class="docutils literal notranslate"><span class="pre">replica3</span></code>, because each replica cleans up all stale group members when updating its <code class="docutils literal notranslate"><span class="pre">last_heartbeat</span></code> field.</p>
</div></blockquote>
<p>For shards 0-3, the new instance of <code class="docutils literal notranslate"><span class="pre">replica1</span></code> then reads the shard's offset attribute, which indicates the location in the shard at which the previous instance of <code class="docutils literal notranslate"><span class="pre">replica1</span></code> left off; seeks the read offset in the shard; and continues reading messages from this location. The same process is executed for <code class="docutils literal notranslate"><span class="pre">replica2</span></code> and <code class="docutils literal notranslate"><span class="pre">replica3</span></code>.</p>
<p><a id="explicit-offset-commits"></a></p>
</section>
</section>
<section id="explicit-offset-commits">
<h3>Explicit offset commits<a class="headerlink" href="#explicit-offset-commits" title="Permalink to this heading">¶</a></h3>
<p>In some cases, the &quot;auto-commit&quot; feature can be problematic.
One example are stateful functions that might need to go and consume already being received records upon the function failure.</p>
<p>For that, Nuclio offers a way to accept new events without committing them, and explicitly mark offsets on the relevant stream shard, when the processing is done.
This enables the function to receive and process more events simultaneously.</p>
<p>To enable this feature, set the <code class="docutils literal notranslate"><span class="pre">ExplicitAckMode</span></code> in the trigger's spec to <code class="docutils literal notranslate"><span class="pre">enable</span></code> or <code class="docutils literal notranslate"><span class="pre">explicitOnly</span></code>, where the optional modes are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">enable</span></code> - allows explicit and implicit ack according to the &quot;x-nuclio-stream-no-ack&quot; header</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">disable</span></code>- disables the explicit ack feature and allows only implicit acks (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">explicitOnly</span></code>- allows only explicit acks and disables implicit acks</p></li>
</ul>
<p>To receive more events without committing them, your function handler must respond with a nuclio response object, set the <code class="docutils literal notranslate"><span class="pre">x-nuclio-stream-no-ack</span></code> header to <code class="docutils literal notranslate"><span class="pre">true</span></code> in the request.
This can be done by calling the response's <code class="docutils literal notranslate"><span class="pre">ensure_no_ack()</span></code> method, like this:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">response</span> <span class="o">=</span> <span class="n">nuclio_sdk</span><span class="o">.</span><span class="n">Response</span><span class="p">()</span>
<span class="n">response</span><span class="o">.</span><span class="n">ensure_no_ack</span><span class="p">()</span>
</pre></div>
</div>
<p>To explicitly commit the offset on an event, save the relevant event information in the <code class="docutils literal notranslate"><span class="pre">QualifiedOffset</span></code> object,
and pass it to async function <code class="docutils literal notranslate"><span class="pre">explicit_ack()</span></code> method of the context's response object, like so:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">qualified_offset</span> <span class="o">=</span> <span class="n">nuclio</span><span class="o">.</span><span class="n">QualifiedOffset</span><span class="o">.</span><span class="n">from_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
<span class="k">await</span> <span class="n">context</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">explicit_ack</span><span class="p">(</span><span class="n">qualified_offset</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>NOTES</strong>:</p>
<ul class="simple">
<li><p>Currently, the explicit ack feature is only available for python runtime and functions that have a stream trigger (kafka/v3io).</p></li>
<li><p>The explicit ack feature can be enabled only when using a static worker allocation mode. Meaning that the function metadata must have the following annotation: <code class="docutils literal notranslate"><span class="pre">&quot;nuclio.io/v3iostream-worker-allocation-mode&quot;:&quot;static&quot;</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">QualifiedOffset</span></code> object can be saved in a persistent storage and used to commit the offset on later invocation of the function.</p></li>
<li><p>The call to the <code class="docutils literal notranslate"><span class="pre">explicit_ack()</span></code> method must be awaited, meaning the handler must be an async function, or provide an event loop to run that method. e.g.:</p></li>
</ul>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">nuclio</span>

<span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
    <span class="n">qualified_offset</span> <span class="o">=</span> <span class="n">nuclio</span><span class="o">.</span><span class="n">QualifiedOffset</span><span class="o">.</span><span class="n">from_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">explicit_ack</span><span class="p">(</span><span class="n">qualified_offset</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;acked&quot;</span>
</pre></div>
</div>
<p><a id="ui-config"></a></p>
</section>
</section>
<section id="dashboard-configuration">
<h2>Dashboard configuration<a class="headerlink" href="#dashboard-configuration" title="Permalink to this heading">¶</a></h2>
<p>As of Nuclio v1.1.33 / v1.3.20, you can configure the following configuration parameters from the Nuclio dashboard:</p>
<ul class="simple">
<li><p><strong>URL</strong>: A consumer-group URL of the form <code class="docutils literal notranslate"><span class="pre">http://v3io-webapi:8081/&lt;container</span> <span class="pre">name&gt;/&lt;stream</span> <span class="pre">path&gt;&#64;&lt;consumer</span> <span class="pre">group</span> <span class="pre">name&gt;</span></code>; for example, <code class="docutils literal notranslate"> <span class="pre">http://v3io-webapi:8081/bigdata/my-stream&#64;cg0</span></code>.</p></li>
<li><p><strong>Max Workers</strong>: The maximum number of workers to allocate for handling the messages of incoming stream shards. Whenever a worker is available and a message reads a shard, the processing is handled by the available worker.</p></li>
<li><p><strong>Worker Availability Timeout</strong>: DEPRECATED (ignored)</p></li>
<li><p><strong>Partitions</strong>: DEPRECATED (ignored). As explained in the previous sections, in the current release, the assignment of shards (&quot;partitions&quot;) to replicas is handled automatically.</p></li>
<li><p><strong>Seek To</strong>: The location (offset) within the message from which to consume records when there's no committed offset in the shard's offset attribute. After an offset is committed for a shard in the consumer group, this offset is always used and the <strong>Seek To</strong> parameter is ignored for this shard.</p></li>
<li><p><strong>Read Batch Size</strong>: Read batch size - the number of messages to read in each read request that's submitted to the platform.</p></li>
<li><p><strong>Polling Interval (ms)</strong>: The time, in milliseconds, to wait between reading messages from the platform stream.</p></li>
<li><p><strong>Username</strong>: DEPRECATED (ignored)</p></li>
<li><p><strong>Password</strong>: A platform access key for accessing the data.</p></li>
<li><p><strong>Worker allocator name</strong>: DEPRECATED (ignored)</p></li>
</ul>
<blockquote>
<div><p><strong>Note:</strong> In future versions of Nuclio, it's planned that the dashboard will better reflect the role of the configuration parameters and add more parameters (such as session timeout and heartbeat interval, which are currently always set to the default values of 10s and 3s, respectively, unless you edit the function-configuration file).</p>
</div></blockquote>
<p><a id="example"></a></p>
</section>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this heading">¶</a></h2>
<p>The easiest way to set up a stream is with the <a class="reference external" href="https://github.com/v3io/v3ctl"><code class="docutils literal notranslate"><span class="pre">v3ctl</span></code></a> platform CLI.
<a class="reference external" href="https://github.com/v3io/v3ctl/releases">Download the latest CLI release</a>, rename the executable binary to <strong>v3ctl</strong>, and add executable permissions by running the following command from a command-line shell:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>chmod<span class="w"> </span>+x<span class="w"> </span>v3ctl
</pre></div>
</div>
<blockquote>
<div><p><strong>Note:</strong></p>
<ul class="simple">
<li><p>When running remotely, from outside of the platform, you need to add the <code class="docutils literal notranslate"><span class="pre">--access-key</span></code> and <code class="docutils literal notranslate"><span class="pre">--webapi-url</span></code> options to all <code class="docutils literal notranslate"><span class="pre">v3ctl</span></code> commands to provide a valid access key and the API URL of the web-APIs service for your platform environment.</p></li>
<li><p>For full usage instructions, including additional options, run <code class="docutils literal notranslate"><span class="pre">v3ctl</span> <span class="pre">&lt;command&gt;</span> <span class="pre">--help</span></code>.
For example, <code class="docutils literal notranslate"><span class="pre">v3ctl</span> <span class="pre">create</span> <span class="pre">stream</span> <span class="pre">--help</span></code> or <code class="docutils literal notranslate"><span class="pre">v3ctl</span> <span class="pre">create</span> <span class="pre">stream</span> <span class="pre">record</span> <span class="pre">--help</span></code>.</p></li>
</ul>
</div></blockquote>
<p>Run the following from a command-line shell to create a platform stream named &quot;test-stream-0&quot; (see the stream-path argument) in the predefined &quot;users&quot; platform data container (<code class="docutils literal notranslate"><span class="pre">--container</span></code>).
The stream has a retention period of 24 hours (<code class="docutils literal notranslate"><span class="pre">--retention-period</span></code>) and 32 shards (<code class="docutils literal notranslate"><span class="pre">--shard-count</span></code>):</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>./v3ctl<span class="w"> </span>create<span class="w"> </span>stream<span class="w"> </span>test-stream-0<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--container<span class="w"> </span>users<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--retention-period<span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--shard-count<span class="w"> </span><span class="m">32</span>
</pre></div>
</div>
<p>Now, use the <code class="docutils literal notranslate"><span class="pre">create</span> <span class="pre">stream</span> <span class="pre">record</span></code> CLI command to add 10 records (IDs <code class="docutils literal notranslate"><span class="pre">1</span></code>-<code class="docutils literal notranslate"><span class="pre">10</span></code>) to each stream shard (<code class="docutils literal notranslate"><span class="pre">--shard-id</span></code>, which is set to a zero-based shard ID - <code class="docutils literal notranslate"><span class="pre">0</span></code>-<code class="docutils literal notranslate"><span class="pre">31</span></code>).
For test purposes, the ingested record data in the example is a string denoting the shard and record IDs - <code class="docutils literal notranslate"><span class="pre">shard-$shard_id-record-$record_id</span></code> (<code class="docutils literal notranslate"><span class="pre">--data</span></code>).
As in the <code class="docutils literal notranslate"><span class="pre">create</span> <span class="pre">stream</span></code> command, the stream path is set to a &quot;test-stream-0&quot; stream in the root directory of the &quot;users&quot; data container, by using the stream-path argument and the <code class="docutils literal notranslate"><span class="pre">--container</span></code> option.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span>shard_id<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">{</span><span class="m">0</span>..31<span class="o">}</span>
<span class="k">do</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span>record_id<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">{</span><span class="m">1</span>..10<span class="o">}</span>
<span class="w">    </span><span class="k">do</span>
<span class="w">        </span>./v3ctl<span class="w"> </span>create<span class="w"> </span>stream<span class="w"> </span>record<span class="w"> </span>/test-stream-0<span class="w"> </span><span class="se">\</span>
<span class="w">            </span>--container<span class="w"> </span>users<span class="w"> </span><span class="se">\</span>
<span class="w">            </span>--shard-id<span class="w"> </span><span class="nv">$shard_id</span><span class="w"> </span><span class="se">\</span>
<span class="w">            </span>--data<span class="w"> </span>shard-<span class="nv">$shard_id</span>-record-<span class="nv">$record_id</span>
<span class="w">    </span><span class="k">done</span><span class="p">;</span>
<span class="k">done</span><span class="p">;</span>
</pre></div>
</div>
<p>After the command completes successfully, the stream is ready for consumption by a Nuclio function. To test this, do the following from the dashboard's <strong>Projects</strong> page, to define and deploy a function that consumes the stream records and uses a <code class="docutils literal notranslate"><span class="pre">v3ioStream</span></code> trigger.</p>
<ol class="arabic">
<li><p>Select an existing project or create a new project, and then create a new Python function. Select to create the function from scratch.</p></li>
<li><p>On the function page, in the <strong>Code</strong> tab, set <strong>Code entry type</strong> to &quot;Source code (edit online)&quot; (default), and enter the following code in the <strong>Source code</strong> text box to define a function that logs the shard-ID event body and sleeps for 5 seconds:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>


<span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
    <span class="n">context</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug_with</span><span class="p">(</span><span class="s1">&#39;Got event&#39;</span><span class="p">,</span> <span class="n">shard_id</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">shard_id</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Select the <strong>Triggers</strong> tab, and then select <strong>Create a new trigger</strong>.
In the <strong>Name</strong> text box, enter the trigger name &quot;V3IO stream&quot;, and in the <strong>Class</strong> field select &quot;V3IO stream&quot; from the drop-down list.
Use the following trigger configuration:</p>
<ul class="simple">
<li><p><strong>URL</strong> - <code class="docutils literal notranslate"><span class="pre">http://v3io-webapi:8081/users/test-stream-0&#64;cg0</span></code> (where <code class="docutils literal notranslate"><span class="pre">/users/test-stream-0</span></code> is the stream path and <code class="docutils literal notranslate"><span class="pre">cg0</span></code> is the name of the consumer group to use).</p></li>
<li><p><strong>Max Workers</strong> - <code class="docutils literal notranslate"><span class="pre">8</span></code>.
This value signifies the number of workers assigned to handle all the shards.
You can also set it to a different number.</p></li>
<li><p><strong>Seek To</strong> - <code class="docutils literal notranslate"><span class="pre">Earliest</span></code>.
(If you use <code class="docutils literal notranslate"><span class="pre">Latest</span></code>, only records that are ingested after the function is deployed will be read, so you won't read the records that you already added in the previous step.)</p></li>
<li><p><strong>Password</strong> - a valid platform access key.</p></li>
</ul>
<p>For all other configuration fields, use the default configuration.
(If you're required to set <strong>Partitions</strong>, enter <code class="docutils literal notranslate"><span class="pre">0</span></code>).</p>
</li>
<li><p>Select <strong>Deploy</strong> to deploy your function.</p></li>
</ol>
<p>After the deployment succeeds, check the logs of the function pods and see the information about the Nuclio events that are handled by the function. You can view the logs by running <code class="docutils literal notranslate"><span class="pre">kubectl</span></code> from a platform web-shell or a Jupyter Notebook service, or from the platform dashboard's <strong>Logs</strong> page (when the log-forwarder service is enabled). The logs should contain the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="o">...</span> <span class="s2">&quot;message&quot;</span><span class="p">:</span><span class="s2">&quot;Got event&quot;</span><span class="p">,</span><span class="s2">&quot;more&quot;</span><span class="p">:</span><span class="s2">&quot;shard_id=&lt;shard ID&gt; || body=shard-&lt;shard ID&gt;-record-&lt;record ID&gt; || worker_id=&lt;worker ID&gt;&quot;</span> <span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>To clean up, delete the function from the dashboard's <strong>Projects | &lt;project&gt; | Functions</strong> tab, and then run the following <code class="docutils literal notranslate"><span class="pre">v3ctl</span></code> CLI command from a command-line shell to delete the stream:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>./v3ctl<span class="w"> </span>delete<span class="w"> </span>stream<span class="w"> </span>--container<span class="w"> </span>users<span class="w"> </span>test-stream-0
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">nuclio</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../concepts/architecture.html">Architecture</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, nuclio.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/reference/triggers/v3iostream.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>