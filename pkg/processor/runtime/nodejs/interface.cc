/*
Copyright 2017 The Nuclio Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Based on samples/process.cc in V8 repo

#include <libplatform/libplatform.h>
#include <v8.h>

#include <iostream>
#include <map>
#include <sstream>
#include <string>

#include <string.h>

#include "interface.h"

namespace nuclio {
// Auto generated by Go
#include "_cgo_export.h"
}

using std::map;
using std::pair;
using std::string;

using v8::Context;
using v8::Date;
using v8::EscapableHandleScope;
using v8::External;
using v8::Function;
using v8::FunctionTemplate;
using v8::Global;
using v8::HandleScope;
using v8::Integer;
using v8::Isolate;
using v8::Local;
using v8::MaybeLocal;
using v8::Name;
using v8::NamedPropertyHandlerConfiguration;
using v8::NewStringType;
using v8::Object;
using v8::ObjectTemplate;
using v8::PropertyCallbackInfo;
using v8::Script;
using v8::String;
using v8::TryCatch;
using v8::Value;

void *unwrap_ptr(Local<Object> obj) {
  Local<External> field = Local<External>::Cast(obj->GetInternalField(0));
  return field->Value();
}

// Event methods

// Helper function to get all string methods
void getEventString(char *(func)(void *), const PropertyCallbackInfo<Value> &info) {
  void *ptr = unwrap_ptr(info.Holder());
  char *value = func(ptr);
  info.GetReturnValue().Set(String::NewFromUtf8(
    info.GetIsolate(), value, NewStringType::kNormal, strlen(value)).ToLocalChecked());
}

void GetEventVersion(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  void *ptr = unwrap_ptr(info.Holder());
  long long value = nuclio::eventVersion(ptr);
  return info.GetReturnValue().Set(Integer::New(info.GetIsolate(), value));
}

void GetEventID(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  getEventString(nuclio::eventID, info);
}

void GetEventSize(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  void *ptr = unwrap_ptr(info.Holder());
  long long value = nuclio::eventSize(ptr);
  return info.GetReturnValue().Set(Integer::New(info.GetIsolate(), value));
}

void GetEventTriggerClass(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  getEventString(nuclio::eventTriggerClass, info);
}

void GetEventTriggerKind(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  getEventString(nuclio::eventTriggerKind, info);
}

void GetEventContentType(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  getEventString(nuclio::eventContentType, info);
}

void GetEventBody(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  getEventString(nuclio::eventBody, info);
}

void GetEventTimestamp(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  void *ptr = unwrap_ptr(info.Holder());
  double value = nuclio::eventTimestamp(ptr);
  info.GetReturnValue().Set(Date::New(info.GetIsolate(), value));
}

void GetEventPath(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  getEventString(nuclio::eventPath, info);
}

void GetEventURL(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  getEventString(nuclio::eventURL, info);
}

void GetEventMethod(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  getEventString(nuclio::eventMethod, info);
}

void getEventMap(char *(func)(void *), const PropertyCallbackInfo<Value> &info) {
  void *ptr = unwrap_ptr(info.Holder());
  char *value = func(ptr);

  Local<String> json = String::NewFromUtf8(
    info.GetIsolate(), value, NewStringType::kNormal, strlen(value)).ToLocalChecked();
  Local<Value> parsed = v8::JSON::Parse(info.GetIsolate(), json).ToLocalChecked();
  Local<Object> headers = Local<Object>::Cast(parsed);
  info.GetReturnValue().Set(headers);
}

void GetEventHeaders(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  getEventMap(nuclio::eventHeaders, info);
}

void GetEventFields(Local<String> name, const PropertyCallbackInfo<Value> &info) {
  getEventMap(nuclio::eventFields, info);
}


// TODO: Must be a sync with interface.go
enum {
  LOG_LEVEL_ERROR,
  LOG_LEVEL_WARNING,
  LOG_LEVEL_INFO,
  LOG_LEVEL_DEBUG
};

void contextLog(const v8::FunctionCallbackInfo<v8::Value>& args, int level) {
  if (args.Length() < 1) {
    // TODO: Raise exception in JS
    return;
  }

  void *ptr = unwrap_ptr(args.Holder());

  Isolate* isolate = args.GetIsolate();
  HandleScope scope(isolate);
  Local<Value> arg = args[0];
  String::Utf8Value message(isolate, arg);

  nuclio::contextLog(ptr, level, *message);
}

void ContextLogError(const v8::FunctionCallbackInfo<v8::Value>& args) {
  contextLog(args, LOG_LEVEL_ERROR);
}

void ContextLogWarning(const v8::FunctionCallbackInfo<v8::Value>& args) {
  contextLog(args, LOG_LEVEL_WARNING);
}


void ContextLogInfo(const v8::FunctionCallbackInfo<v8::Value>& args) {
  contextLog(args, LOG_LEVEL_INFO);
}

void ContextLogDebug(const v8::FunctionCallbackInfo<v8::Value>& args) {
  contextLog(args, LOG_LEVEL_DEBUG);
}

void contextLogWith(const v8::FunctionCallbackInfo<v8::Value>& args, int level) {
  if (args.Length() < 2) {
    // TODO: Raise exception in JS
    return;
  }

  void *ptr = unwrap_ptr(args.Holder());

  Isolate* isolate = args.GetIsolate();
  HandleScope scope(isolate);
  Local<Value> arg0 = args[0];
  String::Utf8Value format(isolate, arg0);

  Local<Object> with = Local<Object>::Cast(args[1]);
  MaybeLocal<String> maybe_json = v8::JSON::Stringify(isolate->GetCurrentContext(), with);
  String::Utf8Value json(isolate, maybe_json.ToLocalChecked());
  nuclio::contextLogWith(ptr, level, *format, *json);
}

void ContextLogErrorWith(const v8::FunctionCallbackInfo<v8::Value>& args) {
  contextLogWith(args, LOG_LEVEL_ERROR);
}

void ContextLogWarningWith(const v8::FunctionCallbackInfo<v8::Value>& args) {
  contextLogWith(args, LOG_LEVEL_WARNING);
}

void ContextLogInfoWith(const v8::FunctionCallbackInfo<v8::Value>& args) {
  contextLogWith(args, LOG_LEVEL_INFO);
}

void ContextLogDebugWith(const v8::FunctionCallbackInfo<v8::Value>& args) {
  contextLogWith(args, LOG_LEVEL_DEBUG);
}

class JSWorker {
public:
  JSWorker(Isolate *isolate, Local<String> script, Local<String> handler_name)
      : isolate_(isolate), script_(script), handler_name_(handler_name) {}

  virtual ~JSWorker() {
    context_.Reset();
    handler_.Reset();
  }

  char *initialize() {
    char *error;

    HandleScope handle_scope(isolate_);
    Local<ObjectTemplate> global = ObjectTemplate::New(isolate_);

    // Each handler gets its own context so different handler don't affect each
    // other. Context::New returns a persistent handle which is what we need
    // for the reference to remain after we return from this method. That
    // persistent handle has to be disposed in the destructor.
    v8::Local<v8::Context> context = Context::New(isolate_, NULL, global);
    context_.Reset(isolate_, context);

    // Enter the new context so all the following operations take place
    // within it.
    Context::Scope context_scope(context);

    // Compile and run the script
    error = load_script(script_);
    if (error != NULL) {
      return error;
    }

    Local<Value> handler_val;
    // If there is no handler function, or if it is not a function, bail out
    if (!context->Global()->Get(context, handler_name_).ToLocal(&handler_val)) {
      String::Utf8Value handler_name(isolate_, handler_name_);
      std::ostringstream oss;
      oss << "Can't find " << *handler_name << " in code";
      return strdup(oss.str().c_str());
    }

    if (!handler_val->IsFunction()) {
      std::ostringstream oss;
      String::Utf8Value handler_name(isolate_, handler_name_);
      oss << *handler_name << " is not a function";
      return strdup(oss.str().c_str());
    }

    // It is a function; cast it to a Function
    Local<Function> handler_fun = Local<Function>::Cast(handler_val);

    // Store the function in a Global handle, since we also want
    // that to remain after this call returns
    handler_.Reset(isolate_, handler_fun);

    if (event_template_.IsEmpty()) {
      Local<ObjectTemplate> raw_template = make_event_template();
      event_template_.Reset(isolate_, raw_template);
    }

    if (context_template_.IsEmpty()) {
      Local<ObjectTemplate> raw_template = make_context_template();
      context_template_.Reset(isolate_, raw_template);
    }

    // All done; all went well
    return NULL;
  }

  response_t handle_event(void *nuclio_context, void *nuclio_event) {
    response_t response;
    response.error_message = NULL;

    HandleScope handle_scope(isolate_);
    v8::Local<v8::Context> context =
        v8::Local<v8::Context>::New(isolate_, context_);
    Context::Scope context_scope(context);
    TryCatch try_catch(isolate_);

    // Invoke the handler function, giving the global object as 'this'
    // and one argument, the request.
    Local<Object> event = wrap_event(nuclio_event);
    Local<Object> ctx = wrap_context(nuclio_context);
    const int argc = 2;
    Local<Value> argv[argc] = {ctx, event};
    v8::Local<v8::Function> handler =
        v8::Local<v8::Function>::New(isolate_, handler_);

    Local<Value> result;
    if (!handler->Call(context, context->Global(), argc, argv)
             .ToLocal(&result)) {
      String::Utf8Value error(isolate_, try_catch.Exception());
      response.error_message = strdup(*error);
      return response;
    }

    // TODO: Support more return types
    String::Utf8Value result_str(isolate_, result);
    response.body = strdup(*result_str);
    response.content_type = strdup("text/plain");
    response.status_code = 200;

    return response;
  }

private:
  char *load_script(Local<String> script) {
    HandleScope handle_scope(isolate_);

    // We're just about to compile the script; set up an error handler to
    // catch any exceptions the script might throw.
    TryCatch try_catch(isolate_);

    Local<Context> context(isolate_->GetCurrentContext());

    // Compile the script and check for errors.
    Local<Script> compiled_script;
    if (!Script::Compile(context, script).ToLocal(&compiled_script)) {
      String::Utf8Value error(isolate_, try_catch.Exception());
      return strdup(*error);
    }

    // Run the script!
    Local<Value> result;
    if (!compiled_script->Run(context).ToLocal(&result)) {
      // The TryCatch above is still in effect and will have caught the error.
      String::Utf8Value error(isolate_, try_catch.Exception());
      return strdup(*error);
    }

    return NULL;
  }

  Local<Object> wrap_event(void *ptr) {
    EscapableHandleScope handle_scope(isolate_);

    Local<ObjectTemplate> templ =
        Local<ObjectTemplate>::New(isolate_, event_template_);

    // Create an empty event wrapper.
    Local<Object> result =
        templ->NewInstance(isolate_->GetCurrentContext()).ToLocalChecked();

    // Wrap the event pointer in an External so it can be referenced from
    // within JavaScript.
    Local<External> event_ptr = External::New(isolate_, ptr);

    // Store the request pointer in the JavaScript wrapper.
    result->SetInternalField(0, event_ptr);

    // Return the result through the current handle scope.  Since each
    // of these handles will go away when the handle scope is deleted
    // we need to call Close to let one, the result, escape into the
    // outer handle scope.
    return handle_scope.Escape(result);
  }

  Local<ObjectTemplate> make_event_template() {
    EscapableHandleScope handle_scope(isolate_);

    Local<ObjectTemplate> result = ObjectTemplate::New(isolate_);
    result->SetInternalFieldCount(1);

    // Add accessors for each of the fields of the request.
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "version", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventVersion);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "id", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventID);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "size", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventSize);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "trigger_class", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventTriggerClass);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "trigger_kind", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventTriggerKind);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "content_type", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventContentType);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "body", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventBody);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "timestamp", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventTimestamp);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "path", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventPath);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "url", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventURL);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "method", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventMethod);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "headers", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventHeaders);
    result->SetAccessor(
        String::NewFromUtf8(isolate_, "fields", NewStringType::kInternalized)
            .ToLocalChecked(),
        GetEventFields);

    return handle_scope.Escape(result);
  }

  Local<Object> wrap_context(void *ptr) {
    EscapableHandleScope handle_scope(isolate_);

    Local<ObjectTemplate> templ =
        Local<ObjectTemplate>::New(isolate_, context_template_);

    // Create an empty context wrapper.
    Local<Object> result =
        templ->NewInstance(isolate_->GetCurrentContext()).ToLocalChecked();

    // Wrap the context pointer in an External so it can be referenced from
    // within JavaScript.
    Local<External> context_ptr = External::New(isolate_, ptr);

    // Store the request pointer in the JavaScript wrapper.
    result->SetInternalField(0, context_ptr);

    // Return the result through the current handle scope.  Since each
    // of these handles will go away when the handle scope is deleted
    // we need to call Close to let one, the result, escape into the
    // outer handle scope.
    return handle_scope.Escape(result);
  }

  Local<ObjectTemplate> make_context_template() {
    EscapableHandleScope handle_scope(isolate_);

    Local<ObjectTemplate> result = ObjectTemplate::New(isolate_);
    result->SetInternalFieldCount(1);

    // Add accessors for each of the logging functions
    result->Set(String::NewFromUtf8(isolate_, "log_error", NewStringType::kNormal)
                  .ToLocalChecked(),
              FunctionTemplate::New(isolate_, ContextLogError));
    result->Set(String::NewFromUtf8(isolate_, "log_warning", NewStringType::kNormal)
                  .ToLocalChecked(),
              FunctionTemplate::New(isolate_, ContextLogWarning));
    result->Set(String::NewFromUtf8(isolate_, "log_info", NewStringType::kNormal)
                  .ToLocalChecked(),
              FunctionTemplate::New(isolate_, ContextLogInfo));
    result->Set(String::NewFromUtf8(isolate_, "log_debug", NewStringType::kNormal)
                  .ToLocalChecked(),
              FunctionTemplate::New(isolate_, ContextLogDebug));
    result->Set(String::NewFromUtf8(isolate_, "log_error_with", NewStringType::kNormal)
                  .ToLocalChecked(),
              FunctionTemplate::New(isolate_, ContextLogErrorWith));
    result->Set(String::NewFromUtf8(isolate_, "log_warning_with", NewStringType::kNormal)
                  .ToLocalChecked(),
              FunctionTemplate::New(isolate_, ContextLogWarningWith));
    result->Set(String::NewFromUtf8(isolate_, "log_info_with", NewStringType::kNormal)
                  .ToLocalChecked(),
              FunctionTemplate::New(isolate_, ContextLogInfoWith));
    result->Set(String::NewFromUtf8(isolate_, "log_debug_with", NewStringType::kNormal)
                  .ToLocalChecked(),
              FunctionTemplate::New(isolate_, ContextLogDebugWith));

    return handle_scope.Escape(result);
  }

  Isolate *isolate_;
  Global<Context> context_;
  Local<String> script_;
  Local<String> handler_name_;
  Global<Function> handler_;

  // Static templates, need to populate once
  static Global<ObjectTemplate> event_template_;
  static Global<ObjectTemplate> context_template_;
};


Global<ObjectTemplate> JSWorker::event_template_;
Global<ObjectTemplate> JSWorker::context_template_;

static bool initialized_(false);

extern "C" {

void initialize() {
  if (initialized_) {
    return;
  }

  v8::V8::InitializeICUDefaultLocation("nuclio");
  v8::V8::InitializeExternalStartupData("nuclio");
  v8::Platform *platform = v8::platform::CreateDefaultPlatform();
  v8::V8::InitializePlatform(platform);
  v8::V8::Initialize();

  initialized_ = true;

  // TODO: Inject nodes's require
}

new_result_t new_worker(char *code, char *handler_name) {
  new_result_t result;
  result.worker = NULL;
  result.error_message = NULL;

  Isolate::CreateParams create_params;
  create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator();
  Isolate *isolate = Isolate::New(create_params);
  Isolate::Scope isolate_scope(isolate);
  HandleScope scope(isolate);

  Local<String> source =
      String::NewFromUtf8(isolate, code, NewStringType::kNormal)
          .ToLocalChecked();
  Local<String> handler =
      String::NewFromUtf8(isolate, handler_name, NewStringType::kNormal)
          .ToLocalChecked();

  JSWorker *worker = new JSWorker(isolate, source, handler);
  char *error = worker->initialize();
  if (error != NULL) {
    result.error_message = error;
    return result;
  }

  result.worker = worker;
  return result;
}

response_t handle_event(void *worker, void *context, void *event) {
  JSWorker *jsworker = (JSWorker *)worker;

  return jsworker->handle_event(context, event);
}

} // extern "C"
