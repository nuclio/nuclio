// Code generated by go generate; DO NOT EDIT.

/*
This machine-generated file contains the configuration and source code for function templates,
which may be retrieved from the dashboard's HTTP API by sending a GET request to /function_templates.

The following functions are included for each supported runtime:
dotnetcore (2): helloworld, reverser
golang (6):     eventhub, helloworld, image, ingress, rabbitmq, regexscan
nodejs (2):     dates, reverser
pypy (1):       image
python (5):     encrypt, facerecognizer, helloworld, sentiments, tensorflow
shell (1):      img-convert
*/

package functiontemplates

import (
	"github.com/nuclio/nuclio/pkg/functionconfig"

	"github.com/ghodss/yaml"
)

var FunctionTemplates = []*FunctionTemplate{
	{
		Name: "eventhub",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build:
    commands:
    - apk --update --no-cache add ca-certificates
  resources: {}
  runtime: golang
`),
		SourceCode: `package main

import (
	ctx "context"
	"encoding/json"

	"github.com/nuclio/amqp"
	"github.com/nuclio/nuclio-sdk-go"
)

type metric struct {
	ID                       string  ` + "`" + `json:"id"` + "`" + `
	Latitude                 string  ` + "`" + `json:"latitude"` + "`" + `
	Longitude                string  ` + "`" + `json:"longitude"` + "`" + `
	TirePressure             float32 ` + "`" + `json:"tirePressure"` + "`" + `
	FuelEfficiencyPercentage float32 ` + "`" + `json:"fuelEfficiencyPercentage"` + "`" + `
	Temperature              int     ` + "`" + `json:"temperature"` + "`" + `
	WeatherCondition         string  ` + "`" + `json:"weatherCondition"` + "`" + `
}

type alarm struct {
	ID   string
	Type string
}

type weather struct {
	Temperature      int    ` + "`" + `json:"temperature"` + "`" + `
	WeatherCondition string ` + "`" + `json:"weatherCondition"` + "`" + `
}

func SensorHandler(context *nuclio.Context, event nuclio.Event) (interface{}, error) {

	// get alarms eventhub
	alarmsEventhub := context.DataBinding["alarmsEventhub"].(*amqp.Sender)

	// get enriched fleet eventhub
	enrichedFleetEventhub := context.DataBinding["enrichedFleetEventhub"].(*amqp.Sender)

	// unmarshal the eventhub metric
	eventHubMetric := metric{}
	if err := json.Unmarshal(event.GetBody(), &eventHubMetric); err != nil {
		return nil, err
	}

	// send alarm if tire pressure < threshold
	var MinTirePressureThreshold float32 = 2
	if eventHubMetric.TirePressure < MinTirePressureThreshold {
		marshaledAlarm, err := json.Marshal(alarm{ID: eventHubMetric.ID, Type: "LowTirePressue"})
		if err != nil {
			return nil, err
		}

		// send alarm to event hub
		if err := sendToEventHub(context, marshaledAlarm, alarmsEventhub); err != nil {
			return nil, err
		}
	}

	// prepare to send to spark via eventhub
	// call weather station for little enrichment
	temperature, weatherCondtion, err := getWeather(context, eventHubMetric)
	if err != nil {
		return nil, err
	}

	context.Logger.DebugWith("Got weather", "temp", temperature, "weather", weatherCondtion)

	// assign return values
	eventHubMetric.Temperature = temperature
	eventHubMetric.WeatherCondition = weatherCondtion

	// send to spark
	marshaledMetric, err := json.Marshal(eventHubMetric)
	if err != nil {
		return nil, err
	}

	if err := sendToEventHub(context, marshaledMetric, enrichedFleetEventhub); err != nil {
		return nil, err
	}

	return nil, nil
}

func sendToEventHub(context *nuclio.Context, data []byte, hub *amqp.Sender) error {

	// create an amqp message with the body
	message := amqp.Message{
		Data: data,
	}

	// send the metric
	if err := hub.Send(ctx.Background(), &message); err != nil {
		context.Logger.WarnWith("Failed to send message to eventhub", "err", err)

		return err
	}

	return nil
}

func getWeather(context *nuclio.Context, m metric) (int, string, error) {
	return 30, "stormy", nil
}
`,
	},
	{
		Name: "helloworld",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build: {}
  resources: {}
  runtime: golang
`),
		SourceCode: `/*
Copyright 2017 The Nuclio Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"github.com/nuclio/nuclio-sdk-go"
)

func Handler(context *nuclio.Context, event nuclio.Event) (interface{}, error) {
	context.Logger.Info("This is an unstrucured %s", "log")

	return nuclio.Response{
		StatusCode:  200,
		ContentType: "application/text",
		Body:        []byte("Hello, from nuclio :]"),
	}, nil
}
`,
	},
	{
		Name: "image",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build: {}
  resources: {}
  runtime: golang
`),
		SourceCode: `/*
Copyright 2017 The Nuclio Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// nuclio image conversion and resizing example
// Usage: send an HTTP Post request with the body containing a URL of an image or the actual image binary
//        can specify requested size and format via the URL query e.g.: /?x=50&y=50&format=png

package main

import (
	"bytes"
	"github.com/disintegration/imaging"
	"github.com/nuclio/nuclio-sdk-go"
	"image"
	"net/http"
	"strings"
)

func Handler(context *nuclio.Context, event nuclio.Event) (interface{}, error) {

	// Set default values
	x := 100
	y := 100
	imageType := imaging.JPEG
	respType := "image/jpeg"

	// Extract X, Y, Format from query args
	if xval, err := event.GetFieldInt("x"); err == nil {
		x = xval
	}

	if yval, err := event.GetFieldInt("y"); err == nil {
		y = yval
	}

	if format := event.GetFieldString("format"); format == "png" {
		imageType = imaging.PNG
		respType = "image/png"
	}

	context.Logger.DebugWith("Got request", "path", event.GetPath(), "x", x, "y", y, "format", respType, "ctype", event.GetContentType())

	var img image.Image
	var err error
	if strings.HasPrefix(event.GetContentType(), "text/plain") {
		// if the body is text assume its a URL and read the image from the URL (in the text)
		response, err := http.Get(string(event.GetBody()))
		if err != nil {
			return nil, err
		}
		// Try to decode the returned body (from the HTTP request to the provided URL)
		img, err = imaging.Decode(response.Body)
	} else {
		// if the content is not text assume the Body contains the image and decode it
		r := bytes.NewReader(event.GetBody())
		img, err = imaging.Decode(r)
	}

	// If image Decode failed return an error
	if err != nil {
		context.Logger.Error("Failed to open image  %v", err)
		return nil, err
	}

	// Create a thumbnail with the specified size and format
	thumb := imaging.Thumbnail(img, x, y, imaging.CatmullRom)
	buf := new(bytes.Buffer)
	err = imaging.Encode(buf, thumb, imageType)

	// Return a response with an image and the proper Content Type
	return nuclio.Response{
		StatusCode:  200,
		ContentType: respType,
		Body:        buf.Bytes(),
	}, nil

}
`,
	},
	{
		Name: "ingress",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build: {}
  resources: {}
  runtime: golang
  triggers:
    http:
      attributes:
        ingresses:
          first:
            paths:
            - /first/path
            - /second/path
          second:
            host: my.host.com
            paths:
            - /first/from/host
      class: ""
      kind: http
      maxWorkers: 8
`),
		SourceCode: `/*
Copyright 2017 The Nuclio Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// @nuclio.configure
//
// function.yaml:
//   apiVersion: "nuclio.io/v1beta1"
//   kind: "Function"
//   spec:
//     runtime: "golang"
//     triggers:
//       http:
//         maxWorkers: 8
//         kind: http
//         attributes:
//           ingresses:
//             first:
//               paths:
//               - /first/path
//               - /second/path
//             second:
//               host: my.host.com
//               paths:
//               - /first/from/host

package main

import (
	"github.com/nuclio/nuclio-sdk-go"
)

func Handler(context *nuclio.Context, event nuclio.Event) (interface{}, error) {
	return "Handler called", nil
}
`,
	},
	{
		Name: "rabbitmq",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build: {}
  resources: {}
  runtime: golang
  triggers:
    test_rmq:
      attributes:
        exchangeName: exchange-name
        queueName: queue-name
      class: ""
      kind: rabbit-mq
      url: amqp://user:password@rabbitmq-host:5672
`),
		SourceCode: `/*
Copyright 2017 The Nuclio Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

//
// Listens to a RabbitMQ queue and records any messages posted to a given queue.
// Can retrieve these recorded messages through HTTP GET, demonstrating how a single
// function can be invoked from different triggers.
//

package main

import (
	"io/ioutil"
	"net/http"
	"os"

	"github.com/nuclio/nuclio-sdk-go"
)

const eventLogFilePath = "/tmp/events.json"

func Handler(context *nuclio.Context, event nuclio.Event) (interface{}, error) {
	context.Logger.InfoWith("Received event", "body", string(event.GetBody()))

	// if we got the event from rabbit
	if event.GetTriggerInfo().GetClass() == "async" && event.GetTriggerInfo().GetKind() == "rabbitMq" {

		eventLogFile, err := os.OpenFile(eventLogFilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0600)
		if err != nil {
			return nil, err
		}

		defer eventLogFile.Close()

		// write the body followed by ', '
		for _, dataToWrite := range [][]byte{
			event.GetBody(),
			[]byte(", "),
		} {

			// write the thing to write
			if _, err = eventLogFile.Write(dataToWrite); err != nil {
				return nil, err
			}
		}

		// all's well
		return nil, nil
	}

	// open the log for read
	eventLogFile, err := os.OpenFile(eventLogFilePath, os.O_RDONLY, 0600)
	if err != nil {
		return nil, err
	}

	defer eventLogFile.Close()

	// read the entire file
	eventLogFileContents, err := ioutil.ReadAll(eventLogFile)
	if err != nil {
		return nil, err
	}

	// chop off the last 2 chars and enclose in a [ ]
	eventLogFileContentsString := "[" + string(eventLogFileContents[:len(eventLogFileContents)-2]) + "]"

	// return the contents as JSON
	return nuclio.Response{
		StatusCode:  http.StatusOK,
		ContentType: "application/json",
		Body:        []byte(eventLogFileContentsString),
	}, nil
}
`,
	},
	{
		Name: "regexscan",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build: {}
  resources: {}
  runtime: golang
`),
		SourceCode: `/*
Copyright 2017 The Nuclio Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

//
// Accept a string (event.body) and scan for compliance using a list of regex patterns (SSN, Credit Cards, ..)
// will return a list of compliance violations in Json or "Passed"
// demonstrate the use of structured and unstructured log with different levels
// can be extended to write results to a stream/object storage
//

package main

import (
	"encoding/json"
	"regexp"

	"github.com/nuclio/nuclio-sdk-go"
)

// list of regular expression filters
var rx = map[string]*regexp.Regexp{
	"SSN":         regexp.MustCompile(` + "`" + `\b\d{3}-\d{2}-\d{4}\b` + "`" + `),
	"Credit card": regexp.MustCompile(` + "`" + `\b(?:\d[ -]*?){13,16}\b` + "`" + `)}

func Handler(context *nuclio.Context, event nuclio.Event) (interface{}, error) {

	// Unstructured debug message
	context.Logger.Debug("Process document %s, length %d", event.GetPath(), event.GetSize())

	data := string(event.GetBody())
	matchList := []string{}

	// Test content against a list of RegEx filters
	for k, v := range rx {
		if v.MatchString(string(data)) {
			matchList = append(matchList, "Contains "+k)
		}
	}

	// If we found a filter match add structured warning log message and respond with match list
	if len(matchList) > 0 {
		context.Logger.WarnWith("Document content warning", "path", event.GetPath(), "content", matchList)
		return json.Marshal(matchList)
	}

	return "Passed", nil
}
`,
	},
	{
		Name: "encrypt",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build:
    commands:
    - apk update
    - apk add --no-cache gcc g++ make libffi-dev openssl-dev
    - pip install simple-crypt
  handler: encrypt:encrypt
  resources: {}
  runtime: python
`),
		SourceCode: `# Copyright 2017 The Nuclio Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# Uses simplecrypt to encrypt the body with a key bound to the function as
# an environment variable. We ask pip to install simplecrypt as part of the
# build process, along with some OS level packages (using apk).
#
# Note: It takes a minute or so to install all the dependencies.
#       Why not star https://github.com/nuclio/nuclio while you wait?
#

import os
import simplecrypt

def encrypt(context, event):
	context.logger.info('Using secret to encrypt body')

	# get the encryption key
	encryption_key = os.environ.get('ENCRYPT_KEY', 'some-default-key')

	# encrypt the body
	encrypted_body = simplecrypt.encrypt(encryption_key, event.body)

	# return the encrypted body, and some hard-coded header
	return context.Response(body=str(encrypted_body),
							headers={'x-encrypt-algo': 'aes256'},
							content_type='text/plain',
							status_code=200)
`,
	},
	{
		Name: "facerecognizer",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build:
    commands:
    - pip install cognitive_face tabulate inflection
  resources: {}
  runtime: python
`),
		SourceCode: `# Copyright 2017 The Nuclio Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# Uses Microsoft's Face API to extract face information from the
# picture whose URL is submitted in the request body. The result is
# returned as a table of face objects sorted by their center's
# position in the given picture, left-to-right and then top-to-bottom.
#
# You will need a valid key from Microsoft:
# https://azure.microsoft.com/en-gb/try/cognitive-services/?api=face-api
#
# Once a valid Face API key has been acquired, set it and the appropriate
# regional base URL as the environment for this function
# (in the config section).
#

# We can also configure the function inline - through a specially crafted
# comment such as the below. This is functionally equivalent to creating
# a function.yaml file.

# @nuclio.configure
#
# function.yaml:
#   apiVersion: "nuclio.io/v1beta1"
#   kind: "Function"
#   spec:
#     build:
#       commands:
#       - "pip install cognitive_face tabulate inflection"
#

import os
import cognitive_face as cf
import tabulate
import inflection


def handler(context, event):

    # extract the stuff we need
    image_url = event.body.decode('utf-8').strip()
    key = os.environ.get('FACE_API_KEY')
    base_url = os.environ.get('FACE_API_BASE_URL')

    if key is None:
        context.logger.warn('Face API key not set, cannot continue')
        return _build_response(context, 'Function misconfigured: Face API key not set', 503)

    if base_url is None:
        context.logger.warn('Face API base URL not set, cannot continue')
        return _build_response(context, 'Function misconfigured: Face API base URL not set', 503)

    if not image_url:
        context.logger.warn('No URL given in request body')
        return _build_response(context, 'Image URL required', 400)

    # configure cognitive face wrapper
    cf.Key.set(key)
    cf.BaseUrl.set(base_url)

    # attempt to request using the provided info
    try:
        context.logger.info('Requesting detection from Face API: {0}'.format(image_url))
        detected_faces = cf.face.detect(image_url,
                                        face_id=False,
                                        attributes='age,gender,glasses,smile,emotion')
    except Exception as error:
        context.logger.warn('Face API error occurred: {0}'.format(error))
        return _build_response(context, 'Face API error occurred', 503)

    parsed_faces = []

    # determine the center point of each detected face and map it to its attributes,
    # as well as clean up the retreived data for viewing comfort
    for face in detected_faces:
        coordinates = face['faceRectangle']
        attributes = face['faceAttributes']

        center_x = coordinates['left'] + coordinates['width'] / 2
        center_y = coordinates['top'] + coordinates['height'] / 2

        # determine the primary emotion based on its weighing
        primary_emotion = sorted(attributes['emotion'].items(), key=lambda item: item[1])[-1][0]

        parsed_face = {
            'x': center_x,
            'y': center_y,
            'position': '({0},{1})'.format(int(center_x), int(center_y)),
            'gender': inflection.humanize(attributes['gender']),
            'age': int(attributes['age']),
            'glasses': inflection.humanize(inflection.underscore(attributes['glasses'])),
            'primary_emotion': inflection.humanize(primary_emotion),
            'smile': '{0:.1f}%'.format(attributes['smile'] * 100),
        }

        parsed_faces.append(parsed_face)

    # sort according to center point, first x then y
    parsed_faces.sort(key=lambda face: (face['x'], face['y']))

    # prepare the data for tabulation
    first_row = ('',) + tuple(face['position'] for face in parsed_faces)
    make_row = lambda name: (inflection.humanize(name),) + tuple(
                            face[name] for face in parsed_faces)

    other_rows = [make_row(name) for name in [
                  'gender', 'age', 'primary_emotion', 'glasses', 'smile']]

    # return the human-readable face data in a neat table format
    return _build_response(context,
                           tabulate.tabulate([first_row] + other_rows,
                                             headers='firstrow',
                                             tablefmt='fancy_grid',
                                             numalign='center',
                                             stralign='center'),
                           200)


def _build_response(context, body, status_code):
    return context.Response(body=body,
                            headers={},
                            content_type='text/plain',
                            status_code=status_code)
`,
	},
	{
		Name: "helloworld",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build: {}
  resources: {}
  runtime: python
`),
		SourceCode: `# Copyright 2017 The Nuclio Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

def handler(context, event):
    context.logger.info('This is an unstructured log')

    return context.Response(body='Hello, from nuclio :]',
                            headers={},
                            content_type='text/plain',
                            status_code=200)
`,
	},
	{
		Name: "sentiments",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build:
    commands:
    - pip install requests vaderSentiment
  resources: {}
  runtime: python
`),
		SourceCode: `# Copyright 2017 The Nuclio Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# uses vader lib (will be installed automatically via build commands) to identify sentiments in the body string
# return score result in the form of: {'neg': 0.0, 'neu': 0.323, 'pos': 0.677, 'compound': 0.6369}
#
# @nuclio.configure
#
# function.yaml:
#   apiVersion: "nuclio.io/v1beta1"
#   kind: "Function"
#   spec:
#     runtime: "python"
#
#     build:
#       commands:
#       - "pip install requests vaderSentiment"
#

from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer

def handler(context, event):
    body = event.body.decode('utf-8')
    context.logger.debug_with('Analyzing ', 'sentence', body)

    analyzer = SentimentIntensityAnalyzer()

    score = analyzer.polarity_scores(body)

    return str(score)
`,
	},
	{
		Name: "tensorflow",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build:
    baseImage: jessie
    commands:
    - apt-get update && apt-get install -y wget
    - wget http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz
    - mkdir -p /tmp/tfmodel
    - tar -xzvf inception-2015-12-05.tgz -C /tmp/tfmodel
    - rm inception-2015-12-05.tgz
    - pip install requests numpy tensorflow
  resources: {}
  runtime: python:3.6
`),
		SourceCode: `# Copyright 2017 The Nuclio Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This function uses TensorFlow to perform image recognition.
# It takes advantage of nuclio's inline configuration to indicate
# its pip dependencies, as well as the linux distribution
# to use for the deployed function's container.
#
# You can try invoking this function by passing any .jpg image's URL
# in the request's body. For instance:
# http://www.lpcsathletics.org/wp-content/uploads/2017/08/soccer-5.jpg
#
# This example is based on the example in TensorFlow's official repository:
# https://github.com/tensorflow/models/blob/master/tutorials/image/imagenet/classify_image.py
#
# Simple image classification with Inception
#
# Runs image classification with Inception trained on ImageNet 2012
# Challenge data set.
#
# This program creates a graph from a saved GraphDef protocol buffer,
# and runs inference on an input JPEG image. It outputs human readable
# strings of up to the top 5 predictions along with their probabilities.

# @nuclio.configure
#
# function.yaml:
#   apiVersion: "nuclio.io/v1beta1"
#   kind: "Function"
#   spec:
#     runtime: "python:3.6"
#
#     build:
#       baseImage: jessie
#       commands:
#       - "apt-get update && apt-get install -y wget"
#       - "wget http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz"
#       - "mkdir -p /tmp/tfmodel"
#       - "tar -xzvf inception-2015-12-05.tgz -C /tmp/tfmodel"
#       - "rm inception-2015-12-05.tgz"
#       - "pip install requests numpy tensorflow"

import os
import os.path
import re
import requests
import shutil
import tarfile
import traceback
import threading

import numpy as np
import tensorflow as tf


def classify(context, event):

    # we're going to need a unique temporary location to handle each event,
    # as we download a file as part of each function invocation
    temp_dir = Helpers.create_temporary_dir(context, event)

    # wrap everything with error handling such that any exception raised
    # at any point will still return a proper response
    try:

        # if we're not ready to handle this request yet, deny it
        if not FunctionState.done_loading:
            context.logger.warn_with('Model data not done loading yet, denying request')
            raise NuclioResponseError('Model data not loaded yet, cannot serve this request',
                                      requests.codes.service_unavailable)

        # read the event's body to determine the target image URL
        # TODO: in the future this can also take binary image data if provided with an appropriate content-type
        image_url = event.body.decode('utf-8').strip()

        # download the image to our temporary location
        image_target_path = os.path.join(temp_dir, 'downloaded_image.jpg')
        Helpers.download_file(context, image_url, image_target_path)

        # run the inference on the image
        results = Helpers.run_inference(context, image_target_path, 5, 0.3)

        # return a response with the result
        return context.Response(body=str(results),
                                headers={},
                                content_type='text/plain',
                                status_code=requests.codes.ok)

    # convert any NuclioResponseError to a response to be returned from our handler.
    # the response's description and status will appropriately convey the underlying error's nature
    except NuclioResponseError as error:
        return error.as_response(context)

    # if anything we didn't count on happens, respond with internal server error
    except Exception as error:
        context.logger.warn_with('Unexpected error occurred, responding with internal server error',
                                 exc=str(error))

        message = 'Unexpected error occurred: {0}\n{1}'.format(error, traceback.format_exc())
        return NuclioResponseError(message).as_response(context)

    # clean up after ourselves regardless of whether we succeeded or failed
    finally:
        shutil.rmtree(temp_dir)


class NuclioResponseError(Exception):

    def __init__(self, description, status_code=requests.codes.internal_server_error):
        self._description = description
        self._status_code = status_code

    def as_response(self, context):
        return context.Response(body=self._description,
                                headers={},
                                content_type='text/plain',
                                status_code=self._status_code)


class FunctionState(object):
    """
    This class has classvars that are set by methods invoked during file import,
    such that handler invocations can re-use them.
    """

    # holds the TensorFlow graph def
    graph = None

    # holds the node id to human string mapping
    node_lookup = None

    # holds a boolean indicating if we're ready to handle an invocation or haven't finished yet
    done_loading = False


class Paths(object):

    # the directory in the deployed function container where the data model is saved
    model_dir = os.getenv('MODEL_DIR', '/tmp/tfmodel/')

    # paths of files within the model archive used to create the graph
    label_lookup_path = os.path.join(model_dir,
                                     os.getenv('LABEL_LOOKUP_FILENAME',
                                               'imagenet_synset_to_human_label_map.txt'))

    uid_lookup_path = os.path.join(model_dir,
                                   os.getenv('UID_LOOKUP_FILENAME',
                                             'imagenet_2012_challenge_label_map_proto.pbtxt'))

    graph_def_path = os.path.join(model_dir,
                                  os.getenv('GRAPH_DEF_FILENAME',
                                            'classify_image_graph_def.pb'))


class Helpers(object):

    @staticmethod
    def create_temporary_dir(context, event):
        """
        Creates a uniquely-named temporary directory (based on the given event's id) and returns its path.
        """
        temp_dir = '/tmp/nuclio-event-{0}'.format(event.id)
        os.makedirs(temp_dir)

        context.logger.debug_with('Created temporary directory', path=temp_dir)

        return temp_dir

    @staticmethod
    def run_inference(context, image_path, num_predictions, confidence_threshold):
        """
        Runs inference on the image in the given path.
        Returns a list of up to N=num_prediction tuples (prediction human name, confidence score).
        Only takes predictions whose confidence score meets the provided confidence threshold.
        """

        # read the image binary data
        with tf.gfile.FastGFile(image_path, 'rb') as f:
            image_data = f.read()

        # run the graph's softmax tensor on the image data
        with tf.Session(graph=FunctionState.graph) as session:
            softmax_tensor = session.graph.get_tensor_by_name('softmax:0')
            predictions = session.run(softmax_tensor, {'DecodeJpeg/contents:0': image_data})
            predictions = np.squeeze(predictions)

        results = []

        # take the num_predictions highest scoring predictions
        top_predictions = reversed(predictions.argsort()[-num_predictions:])

        # look up each predicition's human-readable name and add it to the
        # results if it meets the confidence threshold
        for node_id in top_predictions:
            name = FunctionState.node_lookup[node_id]

            score = predictions[node_id]
            meets_threshold = score > confidence_threshold

            # tensorflow's float32 must be converted to float before logging, not JSON-serializable
            context.logger.info_with('Found prediction',
                                     name=name,
                                     score=float(score),
                                     meets_threshold=meets_threshold)

            if meets_threshold:
                results.append((name, score))

        return results

    @staticmethod
    def on_import():
        """
        This function is called when the file is imported, so that model data
        is loaded to memory only once per function deployment.
        """

        # load the graph def from trained model data
        FunctionState.graph = Helpers.load_graph_def()

        # load the node ID to human-readable string mapping
        FunctionState.node_lookup = Helpers.load_node_lookup()

        # signal that we're ready
        FunctionState.done_loading = True

    @staticmethod
    def load_graph_def():
        """
        Imports the GraphDef data into TensorFlow's default graph, and returns it.
        """

        # verify that the declared graph def file actually exists
        if not tf.gfile.Exists(Paths.graph_def_path):
            raise NuclioResponseError('Failed to find graph def file', requests.codes.service_unavailable)

        # load the TensorFlow GraphDef
        with tf.gfile.FastGFile(Paths.graph_def_path, 'rb') as f:
            graph_def = tf.GraphDef()
            graph_def.ParseFromString(f.read())

            tf.import_graph_def(graph_def, name='')

        return tf.get_default_graph()

    @staticmethod
    def load_node_lookup():
        """
        Composes the mapping between node IDs and human-readable strings. Returns the composed mapping.
        """

        # load the mappings from which we can build our mapping
        string_uid_to_labels = Helpers._load_label_lookup()
        node_id_to_string_uids = Helpers._load_uid_lookup()

        # compose the final mapping of integer node ID to human-readable string
        result = {}
        for node_id, string_uid in node_id_to_string_uids.items():
            label = string_uid_to_labels.get(string_uid)

            if label is None:
                raise NuclioResponseError('Failed to compose node lookup')

            result[node_id] = label

        return result

    @staticmethod
    def download_file(context, url, target_path):
        """
        Downloads the given remote URL to the specified path.
        """
        # make sure the target directory exists
        os.makedirs(os.path.dirname(target_path), exist_ok=True)
        try:
            with requests.get(url, stream=True) as response:
                response.raise_for_status()
                with open(target_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)
        except Exception as error:
            if context is not None:
                context.logger.warn_with('Failed to download file',
                                         url=url,
                                         target_path=target_path,
                                         exc=str(error))
            raise NuclioResponseError('Failed to download file: {0}'.format(url),
                                      requests.codes.service_unavailable)
        if context is not None:
            context.logger.info_with('Downloaded file successfully',
                                     size_bytes=os.stat(target_path).st_size,
                                     target_path=target_path)

    @staticmethod
    def _load_label_lookup():
        """
        Loads and parses the mapping between string UIDs and human-readable strings. Returns the parsed mapping.
        """

        # verify that the declared label lookup file actually exists
        if not tf.gfile.Exists(Paths.label_lookup_path):
            raise NuclioResponseError('Failed to find Label lookup file', requests.codes.service_unavailable)

        # load the raw mapping data
        with tf.gfile.GFile(Paths.label_lookup_path) as f:
            lookup_lines = f.readlines()

        result = {}

        # parse the raw data to a mapping between string UIDs and labels
        # each line is expected to look like this:
        # n12557064     kidney bean, frijol, frijole
        line_pattern = re.compile(r'(n\d+)\s+([ \S,]+)')

        for line in lookup_lines:
            matches = line_pattern.findall(line)

            # extract the uid and label from the matches
            # in our example, uid will be "n12557064" and label will be "kidney bean, frijol, frijole"
            uid = matches[0][0]
            label = matches[0][1]

            # insert the UID and label to our mapping
            result[uid] = label

        return result

    @staticmethod
    def _load_uid_lookup():
        """
        Loads and parses the mapping between node IDs and string UIDs. Returns the parsed mapping.
        """

        # verify that the declared uid lookup file actually exists
        if not tf.gfile.Exists(Paths.uid_lookup_path):
            raise NuclioResponseError('Failed to find UID lookup file', requests.codes.service_unavailable)

        # load the raw mapping data
        with tf.gfile.GFile(Paths.uid_lookup_path) as f:
            lookup_lines = f.readlines()

        result = {}

        # parse the raw data to a mapping between integer node IDs and string UIDs
        # this file is expected to contains entries such as this:
        #
        # entry
        # {
        #   target_class: 443
        #   target_class_string: "n01491361"
        # }
        #
        # to parse it, we'll iterate over the lines, and for each line that begins with "  target_class:"
        # we'll assume that the next line has the corresponding "target_class_string"
        for i, line in enumerate(lookup_lines):

            # we found a line that starts a new entry in our mapping
            if line.startswith('  target_class:'):
                # target_class represents an integer value for node ID - convert it to an integer
                target_class = int(line.split(': ')[1])

                # take the string UID from the next line,
                # and clean up the quotes wrapping it (and the trailing newline)
                next_line = lookup_lines[i + 1]
                target_class_string = next_line.split(': ')[1].strip('"\n ')

                # insert the node ID and string UID to our mapping
                result[target_class] = target_class_string

        return result


# perform the loading in another thread to not block import - the function
# handler will gracefully decline requests until we're ready to handle them
t = threading.Thread(target=Helpers.on_import)
t.start()
`,
	},
	{
		Name: "image",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build:
    commands:
    - pip install pillow
  handler: resize:handler
  resources: {}
  runtime: pypy
`),
		SourceCode: `#!/bin/bash

# Copyright 2017 The Nuclio Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

case $1 in
    -h | --help ) echo "usage: $(basename $0) PORT"; exit;;
esac

if [ $# -ne 1 ]; then
    1>&2 echo "error: wrong number of arguments"
    exit 1
fi

port=$1

curl \
    --output nuclio-logo-small.png \
    --data-binary @nuclio-logo.png \
    http://localhost:${port}\?ratio\=0.1
`,
	},
	{
		Name: "dates",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build:
    commands:
    - npm install --global moment
  handler: handler
  resources: {}
  runtime: nodejs
`),
		SourceCode: `/*
Copyright 2017 The Nuclio Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Uses moment.js (installed as part of the build) to add a given amount of time
// to "now", and returns this as string. Invoke with a JSON containing:
//  - value: some number
//  - unit: some momentjs unit, as a string - e.g. days, d, hours, miliseconds
//
// For example, the following will add 3 hours to current time and return the response:
// {
//     "value": 3,
//     "unit": "hours"
// }
//

var moment = require('moment');

exports.handler = function(context, event) {
    var request = JSON.parse(event.body);
    var now = moment();

    context.logger.infoWith('Adding to now', {
        'request': request,
        'to': now.format()
    });

    now.add(request.value, request.unit);

    context.callback(now.format());
};
`,
	},
	{
		Name: "reverser",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build: {}
  resources: {}
  runtime: nodejs
`),
		SourceCode: `/*
Copyright 2017 The Nuclio Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

exports.handler = function(context, event) {
    var body = event.body.toString(); // event.body is a Buffer
    context.logger.info('reversing: ' + body);
    context.callback(body.split('').reverse().join(''));
};

`,
	},
	{
		Name: "helloworld",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build: {}
  resources: {}
  runtime: dotnetcore
`),
		SourceCode: `//  Copyright 2017 The Nuclio Authors.
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

using System;
using Nuclio.Sdk;

public class nuclio
{
  public object helloworld(Context context, Event eventBase)
  {
    context.Logger.Info("This is an unstructured {0}", "log");
    context.Logger.InfoWith("This is a", "structured", "log");
    return new Response() 
      {
		    StatusCode = 200,
		    ContentType = "application/text",
		    Body = "Hello, from nuclio"
	    };
  }
}`,
	},
	{
		Name: "reverser",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build: {}
  resources: {}
  runtime: dotnetcore
`),
		SourceCode: `//  Copyright 2017 The Nuclio Authors.
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

using System;
using Nuclio.Sdk;

public class nuclio
{
  public string reverser(Context context, Event eventBase)
  {
    var charArray = eventBase.GetBody().ToCharArray();
    Array.Reverse(charArray);
    return new string(charArray);
  }
}`,
	},
	{
		Name: "img-convert",
		Configuration: unmarshalConfig(`metadata: {}
spec:
  build:
    commands:
    - apk --update --no-cache add imagemagick
  handler: img-convert.sh:main
  resources: {}
  runtime: shell
`),
		SourceCode: `#
# Demonstrates running a shell script. In this case, ImageMagick is installed on build and "convert"
# is called for each event with stdin as the input (by default, this is fed with the event body).
#
# NOTE:
#
# This can be achieved without a wrapper script by specifying the "convert" binary as the handler. To do this
# with nuctl you would run (pass --platform local if you're using the local platform):
#
# nuctl deploy -p /dev/null convert \
#     --runtime shell \
#     --handler convert \
#     --runtime-attrs '{"arguments": "- -resize 50% fd:1"}' \
#     --build-command "apk --update --no-cache add imagemagick"
#
# Doing so gives you much greater flexibility than a wrapper script because the arguments can be changed per event.
# If X-nuclio-arguments does not exist in the event headers, the default arguments passed to convert tells it to
# reduce the image to 50%. To run any other mode or any other setting, simply provide this header (note that this is
# unsanitized). For example, to reduce the received image to 10% of its size, set X-nuclio-arguments to
# "- -resize 10% fd:1"
#

# @nuclio.configure
#
# function.yaml:
#   apiVersion: "nuclio.io/v1beta1"
#   kind: "Function"
#   spec:
#     runtime: "shell"
#     handler: "img-convert.sh:main"
#
#     build:
#       commands:
#       - "apk --update --no-cache add imagemagick"
#

convert - -resize 50% fd:1`,
	},
}

// no error checking is performed here. this is guaranteed to work, because the strings fed to this function
// are marshalled representations of actual configuration objects that were created while generating this file
func unmarshalConfig(marshalledConfig string) functionconfig.Config {
	config := functionconfig.Config{}

	err := yaml.Unmarshal([]byte(marshalledConfig), &config)
	if err != nil {
		panic("failed to unmarshal marshaled config")
	}

	return config
}
